package org.ktacademy.effectivekt.item33

//item33：3 使用【伪构造器】

///////////////////////////////////////////////////////////////////////////
// example01
///////////////////////////////////////////////////////////////////////////

//Kotlin 中的构造函数与顶级函数的工作方式类似：
class A()

val a1 = A()

//它们也可以和顶层函数一样被引用
val aReference = ::A
val a2 = aReference()

//类构造函数和函数之间唯一的区别是函数名不是以大写开头的。其实 Kotlin 标准库里面使用了很多手写字母大写的顶层函数，用来作为伪构造器。
//它们看起来很像构造器，很多开发人员都没有意识到它们是底层实现的顶层函数。同时，它们具有SFM（静态工厂方法）的一些优点：它们可以返回类型的子类型，并且它们不需要每次都创建对象。
// 它们也没有构造器相关的要求。例如，辅助构造函数需要立即调用超类的主构造函数或构造函数。当我们使用伪构造函数时，我们可以推迟构造函数的使用。

private fun usage01() {
    /*
    public inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)

    public inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {
        val list = ArrayList<T>(size)
        repeat(size) { index -> list.add(init(index)) }
        return list
    }
     */
    val list = List(5) {
        it * it
    }
    println(list)
}

///////////////////////////////////////////////////////////////////////////
// explanation01：顶层函数和作用域
///////////////////////////////////////////////////////////////////////////
/*
    我们可能想要在类之外创建工厂方法的另一个原因是我们想要在某个特定作用域内创建它。就像我们只在某个特定的类或文件中需要工厂方法一样。
    有些人可能会争辩说这种使用会产生误导，因为对象创建作用域通常与该类可见作用域相关联。所有的这些可能性都是表达意图的强有力的工具，它们需要被理智地使用。
    虽然对象创建的具体方式包含有关它的信息，但在某些情况下使用这种可能性是非常有价值的。
 */