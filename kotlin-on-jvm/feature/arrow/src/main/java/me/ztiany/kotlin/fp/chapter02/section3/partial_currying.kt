package me.ztiany.kotlin.fp.chapter02.section3

/*
偏函数和柯里化有一定关系，它们都是函数式编程中的概念，但又有所不同。

偏函数是指固定一个函数的一些参数，然后产生另一个更小元的函数。例如，有一个函数 f(x, y, z) = x + y + z，现在我们固定其中两个参数 y 和 z，得到一个新函数 g(x) = f(x, y=2, z=3)，这个新函数就是偏函数。

在柯里化中，我们将一个多元函数转化为一系列单元函数，每个单元函数只接收一个参数。例如，对于函数 f(x, y, z) = x + y + z，进行柯里化之后得到一个函数 g(x) = (y) -> (z) -> x + y + z，这里的 g(x) 是一个高阶函数，它返回一个函数 (y) -> (z) -> x + y + z，其中 (y) -> (z) -> x + y + z 是一个接收两个参数 y 和 z 的函数，返回 x + y + z 的值。

因此，可以说偏函数是柯里化的一个特例，它固定了部分参数并返回一个新的函数，而柯里化则是将多元函数转化为一系列单元函数的过程。
 */

///////////////////////////////////////////////////////////////////////////
// 柯里化示例
///////////////////////////////////////////////////////////////////////////

//柯里化示例可以使用一个将两个整数相加的函数来说明。首先，我们可以编写一个函数，该函数获取两个整数并返回它们的和：
private fun add(x: Int, y: Int): Int {
    return x + y
}

//然后，我们可以使用柯里化来将此函数转换为一个接受一个整数并返回一个接受一个整数并返回一个整数的函数。这样，我们可以使用以下方式对该函数进行柯里化：
fun add(x: Int) = fun(y: Int) = x + y

//现在，我们可以将它们分别传递给函数来获得它们的和：
private val sum = add(5)(3)  // sum = 8
//在这个示例中，我们首先使用 add 函数来创建一个柯里化版本的函数，然后使用 add(5) 调用它，这会返回一个接受一个整数并返回一个整数的函数。最后，我们使用 (3) 调用返回的函数来获得它们的和。

///////////////////////////////////////////////////////////////////////////
// 偏函数示例
///////////////////////////////////////////////////////////////////////////

//偏函数示例可以使用一个简单的字符串转换函数来说明。假设我们有一个将字符串转换为整数的函数：
private fun stringToInt(str: String): Int {
    return str.toInt()
}

//但是，如果我们的应用程序需要将十六进制字符串转换为整数，我们可以编写一个函数来实现这个转换：
private fun hexStringToInt(hexStr: String): Int {
    return Integer.parseInt(hexStr, 16)
}

//然而，这个函数只适用于十六进制字符串，如果我们需要将十六进制字符串和普通字符串都转换为整数，我们可以使用偏函数来处理这个问题：
private fun stringToIntBase(base: Int) = fun(str: String) = str.toInt(base)

private val hexStringToInt = stringToIntBase(16)
//在这个示例中，我们首先定义了一个接受一个整数并返回一个接受一个字符串并返回一个整数的函数。然后，我们使用偏函数 stringToIntBase(16) 来创建一个新的函数，该函数将其输入的字符串解释为十六进制，并返回相应的整数。