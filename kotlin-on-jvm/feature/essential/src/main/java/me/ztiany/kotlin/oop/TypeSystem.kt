package me.ztiany.kotlin.oop

/**
 * 与 Java 不同的是，Kotlin 不区分“原始类型”（primitive type）和其他的类型，它们都是同一类型层级结构的一部分。如果定义了一个没有指定父类型的类型，则该类型将是 Any 的直接子类型。
 *
 *  **平台类型**：Kotlin 把 Java方法参数和返回类型中用到的 Object 类型看作 Any（更确切地说是当作“平台类型”）。当在 Kotlin 函数中使用 Any 时，
 *  它会被编译成 Java 字节码中的 Object。
 *
 *  **什么是平台类型**？平台类型本质上就是 Kotlin 不知道可空性信息的类型，所有 Java 引用类型在 Kotlin 中都表现为平台类型。当在 Kotlin 中处理平台类型的值的时候，
 *  它既可以被当作可空类型来处理，也可以被当作非空类型来操作。平台类型的引入是Kotlin兼容Java时的一种权衡设计。试想下，如果所有来自 Java 的值都被看成非空，
 *  那么就容易写出比较危险的代码。反之，如果 Java 中的值都强制当作可空，则会导致大量的 null 检查。综合考量，平台类型是一种折中的设计方案。
 *
 *  注意：Any？是 Any 的父类型，而且是所有类型的根类型。为什么 Any 没有继承 Any?，却是 Any? 的子类型呢？
 *
 * **子类型化与继承**：
 *
 *  1. 什么是子类型化（Subtyping）？如果你只有 Java 这门编程语言的开发经验，很容易陷入一个误区：继承关系决定父子类型关系。因为在 Java 中，
 *  类与类型大部分情况下都是“等价”的（在 Java 泛型出现前）。事实上，“继承”和“子类型化”是两个完全不同的概念。子类型化的核心是一种类型的替代关系，可表示为： S <: T
 *  2. 继承强调的是一种“实现上的复用”，而子类型化是一种类型语义的关系，与实现没关系。部分语言如 Java，由于在声明父子类型关系的同时也声明了继承的关系，所以造成了某种程度上的混淆。
 *  3. 虽然 Any 与 Any？看起来没有继承关系，然而在我们需要用 Any？类型值的地方，显然可以传入一个类型为 Any 的值，这在编译上不会产生问题。
 *
 *  **Any? 与 Any?? 是什么关系**？一个你可能会挑战的问题是，如果 Any？是 Any 的父类型，那么 Any？？是否又是 Any？的父类型？如果成立，那么是否意味着就没有所谓的所有类型的根类型了？
 *  其实，Kotlin 中的可空类型可以看作所谓的 Union Type，近似于数学中的并集。如果用类型的并集来表示 Any？，可写为 Any∪Null。相应的 Any？？就表示为 Any∪Null∪Null，等价于 Any∪Null，
 *  即 Any？？等价于 Any？。因此，说 Any？是所有类型的根类型是没有问题的。
 *
 *  **Nothing**：
 *
 *  1. 在 Kotlin 类型层级结构的最底层是 Nothing 类型。顾名思义，Nothing 是没有实例的类型。Nothing 类型的表达式不会产生任何值。
 *  2. 需要注意的是，任何返回值为 Nothing 的表达式之后的语句都是无法执行的。你是不是感觉这有点像 return 或者 break 的作用？
 *  没错，Kotlin 中 return、throw 等（流程控制中与跳转相关的表达式）返回值都为 Nothing。
 *  3. 有趣的是，与 Nothing 对应的 Nothing？，我们从字面上翻译可能会解释为：可空的空。与 Any、Any？类似，Nothing？是 Nothing 的父类型，
 *  所以 Nothing 处于 Kotlin 类型层级结构的最底层。其实，它只能包含一个值：null，本质上与 null 没有区别。所以我们可以使用 null 作为任何可空类型的值。
 *
 *  **继承类型**：
 *
 * - Kotlin 中的 Int 类型等同于 int；·
 * - Kotlin中 Int？等同于 Integer。
 *
 *  **数组**：Kotlin 中 Array 并不是一种原生的数据结构，而是一种 Array 类，甚至我们可以将 Kotlin 中的 Array 视作集合类的一部分。
 */
fun main() {

}